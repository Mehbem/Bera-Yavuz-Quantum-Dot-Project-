classdef UnUsedFunctionsContainer
    methods
        function [grayImage,imgFiltered,ReversedBWImg,cleanedImg,filteredMask,filterOutlierMask,centroid,CopyCentroid,mask,Contrast_adjusted_Img,Img,mask_scaled,MaskedImage] = Analyzed_QDBinaryImg_With_Dots(obj,scaling,radii_big_circle,center_big_circle,sigma_flatfield,Salt_pepper_pixel_factor,Min_circle_area,I)
            % Description: takes raw image and identifies Quantum Dots (QD) alongside their centroids via preprocessing and postprocessing 
            % Inputs:
                % Img - the raw image matrix
                % scaling - used for scaling down image for quicker processing 
                % radii_big_circle,center_big_circle,sigma_flatfield,Salt_pepper_pixel_factor,Min_circle_area - parameters used for preprocessing and postprocessing ROI 
            % Outputs: 
                % grayImage,imgFiltered,ReversedBWImg,cleanedImg,filteredMask,filterOutlierMask,Contrast_adjusted_Img,Img,MaskedImage - matrices that return different stages of the image processing 
                % centroid,copycentroid - return a m x 2 matrix consisting of the x and y positions of the QD centroids 
                % Mask, Mask_scaled - logical matrices used for creating the ROI within the frame 

            Img = imread(I);
            Img = im2gray(Img);
            grayImage = imresize(Img, scaling);
            sizeImg = size(grayImage);
            sizeImgScaled = size(Img);


            % Get coordinates of the circle.
            angles = linspace(0, 2*pi, 10000);
            x = cos(angles) * radii_big_circle + center_big_circle(1);
            y = sin(angles) * radii_big_circle + center_big_circle(2);
            % Get a mask of the circle
            mask = poly2mask(x, y, sizeImg(1), sizeImg(2));

            % Scaled Up mask
            x_scaled = x ./ scaling;
            y_scaled = y ./ scaling;
            mask_scaled = poly2mask(x_scaled,y_scaled,sizeImgScaled(1),sizeImgScaled(2));


            % Making the shadowing across the image more equal
            FlatFieldAdjustedImg = imflatfield(grayImage,sigma_flatfield);

            % Define the radius for the thin lining
            liningRadius = 10;


            % Dilate the mask to create the outer lining
            se = strel('disk', liningRadius);
            dilatedMask = imdilate(mask, se);

            % Get the thin outer lining by subtracting the original mask from the dilated mask
            thinLining = dilatedMask & ~mask;

            % Apply mask to clear outside image area
            maskedImage = FlatFieldAdjustedImg;
            maskedImage(~mask) = 0;

            % Making the constrast between the dots and the background more clear
            Contrast_adjusted_Img = maskedImage;
            Contrast_adjusted_Img(mask == 1) = imadjust(maskedImage(mask == 1));
            Contrast_adjusted_Img(thinLining) = 255;

            % Getting Rid of Salt-Pepper Noise
            imgFiltered = medfilt2(Contrast_adjusted_Img,Salt_pepper_pixel_factor);

            % Binarizing the image very specifically
            BwImg = imbinarize(imgFiltered, 'adaptive', 'ForegroundPolarity', 'dark', 'Sensitivity', 0.19);

            % Reapply mask outside of circle
            RectanglularBWImg = BwImg;
            RectanglularBWImg(~mask) = 1;

            % Reverse the colour of foreground and background
            ReversedBWImg = ~RectanglularBWImg;
            %imshow(ReversedBWImg)

            % Removing any points or pixels that are anomolies
            cleanedImg = bwareaopen(ReversedBWImg,Min_circle_area);
            %imshow(cleanedImg)


            % Taking the Properties of Remaining Image
            [labeledImage, numObjects] = bwlabel(cleanedImg);
            props = regionprops(labeledImage, 'Area', 'Perimeter', 'Eccentricity',"EulerNumber");
            
    

            % Initialize a mask to keep desired objects
            filteredMask = false(size(cleanedImg));

            % Define thresholds for circularity and eccentricity
            circularityThreshold = 0.5; % Adjust as needed
            eccentricityThreshold = 0.83; % Adjust as needed
            
            % for loop for calculating the circularity
            for k = 1 : numObjects
                area = props(k).Area;
                perimeter = props(k).Perimeter;
                eccentricity = props(k).Eccentricity;
                Hollowness = props(k).EulerNumber; 

                % Calculate circularity
                circularity = 4 * pi * area / (perimeter^2);

                % Filter based on circularity and eccentricity
                if circularity > circularityThreshold && eccentricity < eccentricityThreshold && Hollowness == 1
                    filteredMask(labeledImage == k) = true;
                end
            end

            % Further Filtering Using properties
            [labeledImageV2, numObjectsV2] = bwlabel(filteredMask);
            props_centroid = regionprops(filteredMask, 'Centroid','Area'); % Labelling each centroid
            Centroids = vertcat(props_centroid.Centroid); % Putting them into a list for ease of access
            avg_A_detected_spots = sum([props_centroid.Area])/numObjectsV2; 

            % Doing a minimum distance check to filter out points that have shape and
            % intensity properties but don't follow grid pattern
            filterOutlierMask = false(size(filteredMask));
            for j = 1:numObjectsV2
                DistComp_OutlierQD = sqrt((Centroids(:, 1) - Centroids(j,1)).^2 + (Centroids(:, 2) - Centroids(j,2)).^2);
                SortedDistCompQD = sort(DistComp_OutlierQD);
                MinimumDistCompQD = SortedDistCompQD(2);
                if MinimumDistCompQD <= 80
                    filterOutlierMask(labeledImageV2 == j) = false;
                elseif MinimumDistCompQD <= 180
                    filterOutlierMask(labeledImageV2 == j) = true;
                end
                if props_centroid(j).Area < avg_A_detected_spots/2
                   filterOutlierMask(labeledImageV2 == j) = false; 
                end
            end

            % Array of coordinates scaled and scaling back up
            [FinalbwQDImg,~] = bwlabel(filterOutlierMask);
            statsDots = regionprops(FinalbwQDImg, 'Centroid');
            centroid = vertcat(statsDots.Centroid) ./ scaling;
            CopyCentroid = centroid;
            

             % Masked Image that will be Used for backgrounds
            GrayedImage = im2gray(Img);
            MaskedImage = imadjust(GrayedImage);
            MaskedImage(~mask_scaled) = 0;
        end
        
        function [allNextPts,allPerpPts,p1,p2,p3,p4,p5,p6] = MainAxes(obj,Img,centroid,CopyCentroid,radiusQD) %#ok<*INUSD>
            % Description:
                % - finds a red axis and a blue axis that act as the corresponding x and y axis for the grid pattern of the QD
            % Inputs:
                % Img - raw image matrix
                % centroid, copycentroid - centroid coordinates of the Quantum Dots
                % radiusQD - hardcoded radius of QD for plotting 
            % Outputs:
                % AllNextPts - returns QD on the diagonal of image for red axis (x-axis)
                % AllPerpPts - returns QD on the other diagonal of image for blue axis (y-axis)

            % Calculate distances from each point to the top right corner
            distancesX = sqrt((centroid(:, 1) - size(Img,2)).^2);
            distancesY = sqrt((centroid(:, 2) - 0).^2);
            distances = distancesX + distancesY;

            % Creating a table with the indexs of each point alongside the distance from the top corner
            Indices = 1:length(distances);
            Table_with_dist_ind = table(Indices(:),distances(:),'VariableNames',["Indices", "Distance_to_Corner"]);
            Sorted_Table_with_dist_ind = sortrows(Table_with_dist_ind,"Distance_to_Corner");

            % Estimate the maximum number of points (initial size of coords as an estimate)
            maxPoints = size(centroid, 1);

            % Parameter for Accuracy Wanted
            num_of_QD_diagonal = 5;

            i = 0;
            while i <= length(distances)
                i = i + 1;
                % Get the closest point coordinates
                closestPoint = CopyCentroid(Sorted_Table_with_dist_ind{i,1}, :);
                StartingPt = closestPoint;

                % Finding next closest point
                closestPointNew = closestPoint + [radiusQD, -radiusQD];

                % Preallocate array to store all next points
                allNextPts = zeros(maxPoints+1, 2);


                % For Box pattern creating a lower boundary to prevent skewing of Axes line
                DiameterQD = 2*radiusQD;
                LowerBound = closestPointNew - [2.5*DiameterQD, - 4.5*DiameterQD];
                UpperBound = closestPointNew - [4.5*DiameterQD, - 2.5*DiameterQD];

                % Redefining each set variable
                centroid = CopyCentroid;
                numNextPts = 0;

                % Looping through points to find a diagonal of pts to base all lines off of
                % figure("Name","Axes Finding","Color",skyBlue)
                % imshow(MaskedImage)
                % hold on;

                while ~isempty(centroid)
                    % Testing
                    p1 = plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330],"LineStyle","none");
                    p2 = plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2],"LineStyle","none");
                    % Remove points equal to the closest point
                    targetRow = all(centroid == closestPoint, 2);
                    centroid(targetRow, :) = [];

                    % Check if coords is empty after removal
                    if isempty(centroid)
                        break;
                    end

                    % Making a smaller boxed region below the previous point to search for the next point
                    CoordCompUpper = centroid < UpperBound;
                    CoordCompLower = LowerBound < centroid;
                    % Identify corner points for an imaginary scquare around the next point
                    UpperPattern_mask = (CoordCompUpper(:, 1) == 0) & (CoordCompUpper(:, 2) == 0);
                    LowerPattern_mask = (CoordCompLower(:, 1) == 0) & (CoordCompLower(:, 2) == 0);

                    % Use logical indexing to keep the point that matches
                    NextPt = centroid(UpperPattern_mask & LowerPattern_mask, :);
                    centroid(UpperPattern_mask & LowerPattern_mask, :) = [];

                    % Add the closest point to the list of all next points
                    if ~isempty(NextPt)
                        numNextPts = numNextPts + 1;
                        CopynumNextPts = numNextPts;
                        allNextPts(numNextPts, :) = NextPt;
                        %plot(NextPt(1),NextPt(2),"Marker","o","MarkerSize",5,"MarkerFaceColor",[0 1 0]);
                    end

                    % Use logical indexing to remove all the points before each lowerbound
                    % to prevent the while loop from going on forever
                    RightOfLowerBound = LowerBound < centroid;
                    PointsRemovedRightSide = (RightOfLowerBound(:,1) == 1);
                    centroid(PointsRemovedRightSide,:) = [];

                    % Use logical indexing to remove all the points above each upperbound
                    % to prevent the while loop from going on forever
                    AboveUpperBound = UpperBound > centroid;
                    PointsRemovedAbove = (AboveUpperBound(:,2) == 1);
                    centroid(PointsRemovedAbove,:) = [];

                    % Check if coords is empty after filtering
                    if isempty(centroid)
                        break;
                    end


                    if isempty(NextPt)
                        LowerBound = closestPointNew - [6*DiameterQD, - 8*DiameterQD];
                        UpperBound = closestPointNew - [8*DiameterQD, - 5*DiameterQD];
                        closestPointNew = (UpperBound + LowerBound)./2;
                        %plot(closestPointNew(1),closestPointNew(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.1 0.1 0.9]); % For testing purposes with new images
                    else
                        % Update the closestPoint, closestPointNew, Lowerbound for the next iteration
                        closestPoint = NextPt;
                        closestPointNew = closestPoint + [radiusQD, -radiusQD];
                        LowerBound = closestPointNew - [2.5*DiameterQD, - 4.5*DiameterQD];
                        UpperBound = closestPointNew - [4.5*DiameterQD, - 2.5*DiameterQD];
                    end


                end
                if numNextPts + 1 >= num_of_QD_diagonal
                    break
                elseif (i == length(distances)) && (numNextPts < num_of_QD_diagonal)
                    num_of_QD_diagonal = num_of_QD_diagonal - 1;
                    i = 0;
                elseif num_of_QD_diagonal == 0
                    error("No possible QD were found on the diagonal")
                end

            end

            % Trim the allNextPts array to the actual number of points added
            allNextPts = vertcat(StartingPt,allNextPts(1:CopynumNextPts, :));

            % Find QD across the Perpendicular diagonal
            % --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            PerpCentroid = CopyCentroid;

            PerpStartingPt = allNextPts(round(length(allNextPts)/2),:);
            PerpLowerBoundDown =  PerpStartingPt + [2*DiameterQD,  4*DiameterQD];
            PerpUpperBoundDown = PerpStartingPt + [4*DiameterQD,  2*DiameterQD];

            PerpLowerBoundUp = PerpStartingPt - [4*DiameterQD, 2*DiameterQD];
            PerpUpperBoundUp = PerpStartingPt - [2*DiameterQD, 4*DiameterQD];


            % Preallocate array to store all next points
            allPerpNextPtsDown = zeros(maxPoints, 2);
            allPerpNextPtsUp = zeros(maxPoints, 2);

            % Counter to trim list
            PerpCounterDown = 0;
            PerpCounterUp = 0;

            while PerpUpperBoundDown(2) <= 1920 || PerpLowerBoundDown(2) <= 2000

                % Downwards Search
                p3 = plot(PerpLowerBoundDown(1),PerpLowerBoundDown(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[1, 0, 1],"LineStyle","none");
                p4 = plot(PerpUpperBoundDown(1),PerpUpperBoundDown(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 1, 0],"LineStyle","none");
                % Making a smaller boxed region to search for the next point
                CoordCompUpperDown = PerpCentroid < PerpUpperBoundDown;
                CoordCompLowerDown = PerpLowerBoundDown < PerpCentroid;
                % Identify corner points for an imaginary scquare around the next point
                UpperPattern_maskDown = (CoordCompUpperDown(:, 1) == 1) & (CoordCompUpperDown(:, 2) == 0);
                LowerPattern_maskDown = (CoordCompLowerDown(:, 1) == 1) & (CoordCompLowerDown(:, 2) == 0);
                % Use logical indexing to keep the point that matches
                PerpNextPtDown = PerpCentroid(UpperPattern_maskDown & LowerPattern_maskDown, :);

                % Checking to see if that Point exists
                if isempty(PerpNextPtDown)
                    PerpNextPtDown = (PerpLowerBoundDown + PerpUpperBoundDown)./2;
                    %plot(PerpNextPtDown(1),PerpNextPtDown(2),"Marker","o","MarkerSize",5,"MarkerFaceColor","auto")
                    PerpLowerBoundDown = PerpNextPtDown + [2*DiameterQD,  4*DiameterQD];
                    PerpUpperBoundDown = PerpNextPtDown + [4*DiameterQD,  2*DiameterQD];



                else
                    PerpCounterDown = PerpCounterDown + 1;
                    allPerpNextPtsDown(PerpCounterDown,:) = PerpNextPtDown;
                    PerpLowerBoundDown = PerpNextPtDown + [2*DiameterQD,  4*DiameterQD];
                    PerpUpperBoundDown = PerpNextPtDown + [4*DiameterQD,  2*DiameterQD];
                    %plot(PerpNextPtDown(1),PerpNextPtDown(2),"Marker","o","MarkerSize",5,"MarkerFaceColor","auto")
                end

            end

            while PerpUpperBoundUp(2) >= -100 || PerpLowerBoundUp(2) >= 0

                % Upwards Search
                p5 = plot(PerpLowerBoundUp(1),PerpLowerBoundUp(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[1, 0, 1],"LineStyle","none");
                p6 = plot(PerpUpperBoundUp(1),PerpUpperBoundUp(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 1, 0],"LineStyle","none");
                % Making a smaller boxed region to search for the next point
                CoordCompUpperUp = PerpCentroid < PerpUpperBoundUp;
                CoordCompLowerUp = PerpLowerBoundUp< PerpCentroid;
                % Identify corner points for an imaginary scquare around the next point
                UpperPattern_maskUp = (CoordCompUpperUp(:, 1) == 1) & (CoordCompUpperUp(:, 2) == 0);
                LowerPattern_maskUp = (CoordCompLowerUp(:, 1) == 1) & (CoordCompLowerUp(:, 2) == 0);
                % Use logical indexing to keep the point that matches
                PerpNextPtUp = PerpCentroid(UpperPattern_maskUp & LowerPattern_maskUp, :);

                % Checking to see if that Point exists
                if isempty(PerpNextPtUp)
                    PerpNextPtUp = (PerpLowerBoundUp + PerpUpperBoundUp)./2;
                    %plot(PerpNextPtUp(1),PerpNextPtUp(2),"Marker","o","MarkerSize",5,"MarkerFaceColor","auto")
                    PerpLowerBoundUp = PerpNextPtUp - [2*DiameterQD,  4*DiameterQD];
                    PerpUpperBoundUp = PerpNextPtUp - [4*DiameterQD,  2*DiameterQD];

                else
                    PerpCounterUp = PerpCounterUp + 1;
                    allPerpNextPtsUp(PerpCounterUp,:) = PerpNextPtUp;
                    PerpLowerBoundUp = PerpNextPtUp - [2*DiameterQD,  4*DiameterQD];
                    PerpUpperBoundUp = PerpNextPtUp - [4*DiameterQD,  2*DiameterQD];
                    %plot(PerpNextPtUp(1),PerpNextPtUp(2),"Marker","o","MarkerSize",5,"MarkerFaceColor","auto")
                end
            end


            % Trim the allPerpNextPts array to the actual number of points added
            allPerpPts = vertcat(PerpStartingPt,allPerpNextPtsDown(1:PerpCounterDown, :),allPerpNextPtsUp(1:PerpCounterUp,:));
        end

        function [allNextPts,allPerpPts] = ANC300Axes_MainAxes(obj,Img,centroid,CopyCentroid,radiusQD)
             % Description:
                % - finds a red axis and a blue axis that act as the corresponding x and y axis for the grid pattern of the QD (Does not do plotting like MainAxes function)
            % Inputs:
                % Img - raw image matrix
                % centroid, copycentroid - centroid coordinates of the Quantum Dots
                % radiusQD - hardcoded radius of QD for plotting 
            % Outputs:
                % AllNextPts - returns QD on the diagonal of image for red axis (x-axis)
                % AllPerpPts - returns QD on the other diagonal of image for blue axis (y-axis)

            
            % Calculate distances from each point to the top right corner
            distancesX = sqrt((centroid(:, 1) - size(Img,2)).^2);
            distancesY = sqrt((centroid(:, 2) - 0).^2);
            distances = distancesX + distancesY;

            % Creating a table with the indexs of each point alongside the distance from the top corner
            Indices = 1:length(distances);
            Table_with_dist_ind = table(Indices(:),distances(:),'VariableNames',["Indices", "Distance_to_Corner"]);
            Sorted_Table_with_dist_ind = sortrows(Table_with_dist_ind,"Distance_to_Corner");

            % Estimate the maximum number of points (initial size of coords as an estimate)
            maxPoints = size(centroid, 1);

            % Parameter for Accuracy Wanted
            num_of_QD_diagonal = 5;

            i = 0;
            while i <= length(distances)
                i = i + 1;
                % Get the closest point coordinates
                closestPoint = CopyCentroid(Sorted_Table_with_dist_ind{i,1}, :);
                StartingPt = closestPoint;

                % Finding next closest point
                closestPointNew = closestPoint + [radiusQD, -radiusQD];

                % Preallocate array to store all next points
                allNextPts = zeros(maxPoints+1, 2);


                % For Box pattern creating a lower boundary to prevent skewing of Axes line
                DiameterQD = 2*radiusQD;
                LowerBound = closestPointNew - [2.5*DiameterQD, - 4.5*DiameterQD];
                UpperBound = closestPointNew - [4.5*DiameterQD, - 2.5*DiameterQD];

                % Redefining each set variable
                centroid = CopyCentroid;
                numNextPts = 0;

                while ~isempty(centroid)
                    % Remove points equal to the closest point
                    targetRow = all(centroid == closestPoint, 2);
                    centroid(targetRow, :) = [];

                    % Check if coords is empty after removal
                    if isempty(centroid)
                        break;
                    end

                    % Making a smaller boxed region below the previous point to search for the next point
                    CoordCompUpper = centroid < UpperBound;
                    CoordCompLower = LowerBound < centroid;
                    % Identify corner points for an imaginary scquare around the next point
                    UpperPattern_mask = (CoordCompUpper(:, 1) == 0) & (CoordCompUpper(:, 2) == 0);
                    LowerPattern_mask = (CoordCompLower(:, 1) == 0) & (CoordCompLower(:, 2) == 0);

                    % Use logical indexing to keep the point that matches
                    NextPt = centroid(UpperPattern_mask & LowerPattern_mask, :);
                    centroid(UpperPattern_mask & LowerPattern_mask, :) = [];

                    % Add the closest point to the list of all next points
                    if ~isempty(NextPt)
                        numNextPts = numNextPts + 1;
                        CopynumNextPts = numNextPts;
                        allNextPts(numNextPts, :) = NextPt;

                    end

                    % Use logical indexing to remove all the points before each lowerbound
                    % to prevent the while loop from going on forever
                    RightOfLowerBound = LowerBound < centroid;
                    PointsRemovedRightSide = (RightOfLowerBound(:,1) == 1);
                    centroid(PointsRemovedRightSide,:) = [];

                    % Use logical indexing to remove all the points above each upperbound
                    % to prevent the while loop from going on forever
                    AboveUpperBound = UpperBound > centroid;
                    PointsRemovedAbove = (AboveUpperBound(:,2) == 1);
                    centroid(PointsRemovedAbove,:) = [];

                    % Check if coords is empty after filtering
                    if isempty(centroid)
                        break;
                    end


                    if isempty(NextPt)
                        LowerBound = closestPointNew - [6*DiameterQD, - 8*DiameterQD];
                        UpperBound = closestPointNew - [8*DiameterQD, - 5*DiameterQD];
                        closestPointNew = (UpperBound + LowerBound)./2;

                    else
                        % Update the closestPoint, closestPointNew, Lowerbound for the next iteration
                        closestPoint = NextPt;
                        closestPointNew = closestPoint + [radiusQD, -radiusQD];
                        LowerBound = closestPointNew - [2.5*DiameterQD, - 4.5*DiameterQD];
                        UpperBound = closestPointNew - [4.5*DiameterQD, - 2.5*DiameterQD];
                    end


                end
                if numNextPts + 1 >= num_of_QD_diagonal
                    break
                elseif (i == length(distances)) && (numNextPts < num_of_QD_diagonal)
                    num_of_QD_diagonal = num_of_QD_diagonal - 1;
                    i = 0;
                elseif num_of_QD_diagonal == 0
                    error("No possible QD were found on the diagonal")
                end

            end

            % Trim the allNextPts array to the actual number of points added
            allNextPts = vertcat(StartingPt,allNextPts(1:CopynumNextPts, :));

            % Find QD across the Perpendicular diagonal
            % --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            PerpCentroid = CopyCentroid;

            PerpStartingPt = allNextPts(round(length(allNextPts)/2),:);
            PerpLowerBoundDown =  PerpStartingPt + [2*DiameterQD,  4*DiameterQD];
            PerpUpperBoundDown = PerpStartingPt + [4*DiameterQD,  2*DiameterQD];

            PerpLowerBoundUp = PerpStartingPt - [4*DiameterQD, 2*DiameterQD];
            PerpUpperBoundUp = PerpStartingPt - [2*DiameterQD, 4*DiameterQD];


            % Preallocate array to store all next points
            allPerpNextPtsDown = zeros(maxPoints, 2);
            allPerpNextPtsUp = zeros(maxPoints, 2);

            % Counter to trim list
            PerpCounterDown = 0;
            PerpCounterUp = 0;

            while PerpUpperBoundDown(2) <= 1920 || PerpLowerBoundDown(2) <= 2000

                % Downwards Search

                % Making a smaller boxed region to search for the next point
                CoordCompUpperDown = PerpCentroid < PerpUpperBoundDown;
                CoordCompLowerDown = PerpLowerBoundDown < PerpCentroid;
                % Identify corner points for an imaginary scquare around the next point
                UpperPattern_maskDown = (CoordCompUpperDown(:, 1) == 1) & (CoordCompUpperDown(:, 2) == 0);
                LowerPattern_maskDown = (CoordCompLowerDown(:, 1) == 1) & (CoordCompLowerDown(:, 2) == 0);
                % Use logical indexing to keep the point that matches
                PerpNextPtDown = PerpCentroid(UpperPattern_maskDown & LowerPattern_maskDown, :);

                % Checking to see if that Point exists
                if isempty(PerpNextPtDown)
                    PerpNextPtDown = (PerpLowerBoundDown + PerpUpperBoundDown)./2;
                    %plot(PerpNextPtDown(1),PerpNextPtDown(2),"Marker","o","MarkerSize",5,"MarkerFaceColor","auto")
                    PerpLowerBoundDown = PerpNextPtDown + [2*DiameterQD,  4*DiameterQD];
                    PerpUpperBoundDown = PerpNextPtDown + [4*DiameterQD,  2*DiameterQD];



                else
                    PerpCounterDown = PerpCounterDown + 1;
                    allPerpNextPtsDown(PerpCounterDown,:) = PerpNextPtDown;
                    PerpLowerBoundDown = PerpNextPtDown + [2*DiameterQD,  4*DiameterQD];
                    PerpUpperBoundDown = PerpNextPtDown + [4*DiameterQD,  2*DiameterQD];

                end

            end

            while PerpUpperBoundUp(2) >= -100 || PerpLowerBoundUp(2) >= 0

                % Upwards Search

                % Making a smaller boxed region to search for the next point
                CoordCompUpperUp = PerpCentroid < PerpUpperBoundUp;
                CoordCompLowerUp = PerpLowerBoundUp< PerpCentroid;
                % Identify corner points for an imaginary scquare around the next point
                UpperPattern_maskUp = (CoordCompUpperUp(:, 1) == 1) & (CoordCompUpperUp(:, 2) == 0);
                LowerPattern_maskUp = (CoordCompLowerUp(:, 1) == 1) & (CoordCompLowerUp(:, 2) == 0);
                % Use logical indexing to keep the point that matches
                PerpNextPtUp = PerpCentroid(UpperPattern_maskUp & LowerPattern_maskUp, :);

                % Checking to see if that Point exists
                if isempty(PerpNextPtUp)
                    PerpNextPtUp = (PerpLowerBoundUp + PerpUpperBoundUp)./2;
                    PerpLowerBoundUp = PerpNextPtUp - [2*DiameterQD,  4*DiameterQD];
                    PerpUpperBoundUp = PerpNextPtUp - [4*DiameterQD,  2*DiameterQD];

                else
                    PerpCounterUp = PerpCounterUp + 1;
                    allPerpNextPtsUp(PerpCounterUp,:) = PerpNextPtUp;
                    PerpLowerBoundUp = PerpNextPtUp - [2*DiameterQD,  4*DiameterQD];
                    PerpUpperBoundUp = PerpNextPtUp - [4*DiameterQD,  2*DiameterQD];
                end
            end


            % Trim the allPerpNextPts array to the actual number of points added
            allPerpPts = vertcat(PerpStartingPt,allPerpNextPtsDown(1:PerpCounterDown, :),allPerpNextPtsUp(1:PerpCounterUp,:));
        end

        function [x_main,y,x_perp,y_perp,red_transpose_x,red_transpose_y,blue_transpose_x,blue_transpose_y,b,perp_b,m,perp_m] = GridLines(obj,allNextPts,allPerpPts,grayImage,scaling,num_lines,sep_red,sep_blue)
            % Description:
                % - creates a line of best fit for each axis based on the QD found through both diagonals 
            % Inputs:
                % AllNextPts -  QD on the diagonal of image for red axis (x-axis)
                % AllPerpPts -  QD on the other diagonal of image for blue axis (y-axis)
                % grayImage - raw image gray scaled 
                % scaling - image compressing factor  
                % num_lines - number of lines parellel to each axis line 
                % sep_red - seperation of red lines (hard coded although can be changed by user)
                % sep_blue - seperation of blue lines (hard coded although can be changed by user)
            % Outputs:
                % All variables return their respective names for each line 

            xvals = allNextPts(:, 1);
            yvals = allNextPts(:, 2);

            % Fitting a line using polyfit
            p = polyfit(xvals, yvals, 1);
            m = p(1);
            b = p(2);

            % Defining the y values of the line
            x = linspace(1, 2560,100);
            x_main = x;
            y = m .* x + b;

            % Trimming outside visible region
            xOOB = x > width(grayImage) / scaling;
            yOOB = (y > height(grayImage) / scaling) | y < 0;
            MainOOB = xOOB | yOOB;
            x_main(MainOOB) = NaN;
            y(MainOOB) = NaN;

            % Generate and plot parallel lines for the red line
            red_all_y_shift = zeros(2*num_lines+1,100);
            red_all_x = repmat(x,2*num_lines+1,1);
            red_line_counter = 0;
            for i = -num_lines:num_lines
                b_shift = b + i * sep_red;
                y_shift = m * x + b_shift;
                red_line_counter = red_line_counter + 1;
                red_all_y_shift(red_line_counter,:) = y_shift;
            end
            red_transpose_x = red_all_x';
            red_transpose_y = red_all_y_shift';

            % Determine out-of-bounds (OOB) points
            xOOB = red_all_x > width(grayImage) / scaling;
            yOOB = (red_all_y_shift > height(grayImage) / scaling) | red_all_y_shift < 0;
            OOB = xOOB | yOOB;

            % Set OOB points to NaN
            red_transpose_x(OOB') = NaN; % Transpose OOB to match the transposed matrices
            red_transpose_y(OOB') = NaN; % Transpose OOB to match the transposed matrices


            % Perpendicular slope
            %
            if length(allPerpPts) < 5
                x_perp = x;
                perp_m = -1 / m;  % Negative reciprocal of the original slope
                length_next_pts = length(allNextPts);
                perp_b = allNextPts(round(length_next_pts./2), 2) - perp_m * allNextPts(round(length_next_pts./2), 1);
                y_perp = perp_m .* x_perp + perp_b;
                fprintf("Using The calculated slope method\n")
            else
                fprintf("Using the QD filtered slope method\n")
                % X and Y values of Second Axes
                Perp_xvals = allPerpPts(:, 1);
                Perp_yvals = allPerpPts(:, 2);

                % Fitting a line using polyfit
                p_perp = polyfit(Perp_xvals, Perp_yvals, 1);
                perp_m = p_perp(1);
                perp_b = p_perp(2);

                % Defining the y values of the line
                x = linspace(1, 2560,100);
                x_perp = x;
                y_perp = perp_m .* x + perp_b;
            end

            % Trimming outside visible region
            xOOB = x_perp > width(grayImage) / scaling;
            yOOB = (y_perp > height(grayImage) / scaling) | y_perp < 0;
            MainOOB = xOOB | yOOB;
            x_perp(MainOOB) = NaN;
            y_perp(MainOOB) = NaN;


            % Generate and plot parallel lines for the blue line
            blue_all_y_shift = zeros(2*num_lines+1,100);
            blue_all_x = repmat(x,2*num_lines+1,1);
            blue_line_counter = 0;
            for i = -num_lines:num_lines
                b_shift = perp_b + i * sep_blue;
                y_shift = perp_m * x + b_shift;
                blue_line_counter = blue_line_counter + 1;
                blue_all_y_shift(blue_line_counter,:) = y_shift;
            end
            blue_transpose_x = blue_all_x';
            blue_transpose_y = blue_all_y_shift';

            % Determine out-of-bounds (OOB) points
            xOOB = blue_all_x > width(grayImage) / scaling;
            yOOB = (blue_all_y_shift > height(grayImage) / scaling) | blue_all_y_shift < 0;
            OOB = xOOB | yOOB;

            % Set OOB points to NaN
            blue_transpose_x(OOB') = NaN; % Transpose OOB to match the transposed matrices
            blue_transpose_y(OOB') = NaN; % Transpose OOB to match the transposed matrices
        end

        function [VirtualQDList,FullQDList_sorted,AllPossibleQDList,RealQDCentroids,centroidx,centroidy] = VirtualQD(obj,num_lines,sep_red,sep_blue,m,perp_m,b,perp_b,CopyCentroid,Img)
            % Description:
                % - using the grid pattern previously solved for, does pattern completion to fill in possible missed or not missed QD spots  
            % Inputs:
                % num_lines - number of lines parellel to each axis line 
                % sep_red - seperation of red lines (hard coded although can be changed by user)
                % sep_blue - seperation of blue lines (hard coded although can be changed by user)
                % variables with name variations of b and m are the slopes and intercepts of their respective axes 
            % Outputs:
                % VirtualQDList -  list of all virtual QD
                % FullQDList_sorted - list of both real and virtual QD
                % AllPossibleQDList - list of all possible positions of QD
                % RealQDCentroids - list of real QD
                % centroidx, centroidy - x and y coordinates of real QD respectively 

            % Pre Allocating virtual QD entries and defining a counter
            VirtualQDList = zeros(100, 2);
            AllPossibleQDList = zeros(100, 2);
            DotCounter = 0;
            DotCounter2 = 0;
            for i = -num_lines:num_lines
                for j = -num_lines:num_lines
                    % Calculate new intercepts
                    b1_shift = b + i * sep_red;
                    b2_shift = perp_b + j * sep_blue;

                    % Solve for x and y to find intersection
                    x_intersect = (b2_shift - b1_shift) / (m - perp_m);
                    y_intersect = m * x_intersect + b1_shift;

                    % Plot circle at intersection
                    % Prevention of Real QD and virtual QD overlap
                    DistComp = sqrt((CopyCentroid(:, 1) - x_intersect).^2 + (CopyCentroid(:, 2) - y_intersect).^2);

                    % Prevention of quantum dots outside of visible region being recorded
                    condition = (x_intersect >= 30 && x_intersect <= size(Img, 2)-30) && (y_intersect >= 30 && y_intersect <= size(Img, 1)-30) && all(DistComp > 40);
                    if condition
                        %viscircles([x_intersect, y_intersect], 30, 'Color', [0, 1, 1,0.5], 'LineWidth', 0.5); % Surronding Radius of center point
                        VirtualQD = [x_intersect,y_intersect];
                        DotCounter = DotCounter + 1;
                        VirtualQDList(DotCounter,:) = VirtualQD;
                    end

                    condition2 = (x_intersect >= 30 && x_intersect <= size(Img, 2)-30) && (y_intersect >= 30 && y_intersect <= size(Img, 1)-30);
                    if condition2
                        %viscircles([x_intersect, y_intersect], 30, 'Color', [0, 1, 1,0.5], 'LineWidth', 0.5); % Surronding Radius of center point
                        AllPossibleQD = [x_intersect,y_intersect];
                        DotCounter2 = DotCounter2 + 1;
                        AllPossibleQDList(DotCounter2,:) = AllPossibleQD;
                    end


                end
            end


            % Getting rid of excess entries in the list
            VirtualQDList = VirtualQDList(1:DotCounter,:);
            AllPossibleQDList = AllPossibleQDList(1:DotCounter2,:);



            % Filtering Outlying QD points detected as real
            rows_to_delete_RealQD = false(size(CopyCentroid,1),1);
            for filt = 1:size(CopyCentroid,1)
                DistComp_OutlierQD = sqrt((AllPossibleQDList(:, 1) - CopyCentroid(filt,1)).^2 + (AllPossibleQDList(:, 2) - CopyCentroid(filt,2)).^2);
                minDistOutlierQD = min(DistComp_OutlierQD);
                if minDistOutlierQD >= 50
                    rows_to_delete_RealQD(filt) = true;
                end
            end
            CopyCentroid(rows_to_delete_RealQD,:) = [];

            centroidx = CopyCentroid(:,1);
            centroidy = CopyCentroid(:,2);


            % Filtering Virtual QD points intersecting real QD points
            rows_to_delete_VirtualQD = false(size(VirtualQDList,1),1);
            for filtVirtual = 1:size(VirtualQDList,1)
                DistComp_OutlierVirtualQD = sqrt((CopyCentroid(:, 1) - VirtualQDList(filtVirtual,1)).^2 + (CopyCentroid(:, 2) - VirtualQDList(filtVirtual,2)).^2);
                minDistOutlierVirtualQD = min(DistComp_OutlierVirtualQD);
                if minDistOutlierVirtualQD <= 50 %&& all(DistComp_OutlierQD <=50)
                    rows_to_delete_VirtualQD(filtVirtual)= true;
                end
            end
            VirtualQDList(rows_to_delete_VirtualQD,:) =[];


            % Putting Virtual and Real points into one list
            FullQDList = vertcat(VirtualQDList,CopyCentroid);
            FullQDList_sorted = sortrows(FullQDList, 2);
            RealQDCentroids = CopyCentroid;

        end

        function [DistanceBetweenPoints,NextPt] = RasterScanPatt(obj,radiusQD,StartingQD,FullQDList_sorted,direction,repeatingNum)
             % Description:
                % - path finding for ANC300, user gives movement direction and the path finder finds the next QD in that direction  
            % Inputs:
                % radiusQD - hardcoded approximate radius of each QD
                % startingQD - QD that the path finding starts from
                % FullQDlist_sorted - list of real and virtual QD 
                % direction - direction that the path finder looks for QD. Acceptable inputs are: 'bottomright','bottomleft','topright','topleft'
                % repeatingNum - number of QD found in that direction  
            % Outputs:
                % DistanceBetweenPoints - X and Y distance between each QD within specificed direction
                % Nextpt - centroid coordinate of Next QD within specified direction  

            % For direction can choose bottomright, bottomleft, upperright, upperleft
            DiameterQD = 2*radiusQD;
            DistanceBetweenPoints = zeros(repeatingNum,2);
            counter = 0;

            switch lower(direction)
                case 'bottomright'
                    LowerBound = StartingQD + [2*DiameterQD,  4*DiameterQD];
                    UpperBound = StartingQD + [4*DiameterQD,  2*DiameterQD];
                    PreviousPt = StartingQD;
                    while counter < repeatingNum
                        counter = counter + 1;
                        plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330]);
                        plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2]);
                        % Making a smaller boxed region to search for the next point
                        CoordCompUpper = FullQDList_sorted < UpperBound;
                        CoordCompLower = LowerBound < FullQDList_sorted;
                        % Identify corner points for an imaginary scquare around the next point
                        UpperPattern_mask = (CoordCompUpper(:, 1) == 1) & (CoordCompUpper(:, 2) == 0);
                        LowerPattern_mask = (CoordCompLower(:, 1) == 1) & (CoordCompLower(:, 2) == 0);
                        % Use logical indexing to keep the point that matches
                        NextPt = FullQDList_sorted(UpperPattern_mask & LowerPattern_mask, :);
                        LowerBound = NextPt + [2*DiameterQD,  4*DiameterQD];
                        UpperBound = NextPt + [4*DiameterQD,  2*DiameterQD];
                        % Finding X and Y distance for ANC300 Controller movement
                        XYdistance = PreviousPt - NextPt;
                        % Sketching Raster Scan Path
                        plot(vertcat(PreviousPt(:,1),NextPt(:,1)), vertcat(PreviousPt(:,2),NextPt(:,2)), 'LineStyle', '-', 'Color', [0.4, 0, 0.6,0.4], 'LineWidth',2.5)
                        PreviousPt = NextPt;
                        % Add to list for ease of use later
                        DistanceBetweenPoints(counter,:) = XYdistance;
                    end

                case 'bottomleft'
                    LowerBound = StartingQD - [2*DiameterQD, - 4*DiameterQD];
                    UpperBound = StartingQD - [4*DiameterQD, - 2*DiameterQD];
                    PreviousPt = StartingQD;
                    while counter < repeatingNum
                        counter = counter + 1;
                        plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330]);
                        plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2]);
                        % Making a smaller boxed region to search for the next point
                        CoordCompUpper = FullQDList_sorted < UpperBound;
                        CoordCompLower = LowerBound < FullQDList_sorted;
                        % Identify corner points for an imaginary scquare around the next point
                        UpperPattern_mask = (CoordCompUpper(:, 1) == 0) & (CoordCompUpper(:, 2) == 0);
                        LowerPattern_mask = (CoordCompLower(:, 1) == 0) & (CoordCompLower(:, 2) == 0);
                        % Use logical indexing to keep the point that matches
                        NextPt = FullQDList_sorted(UpperPattern_mask & LowerPattern_mask, :);
                        LowerBound = NextPt - [2*DiameterQD, - 4*DiameterQD];
                        UpperBound = NextPt - [4*DiameterQD, - 2*DiameterQD];
                        % Finding X and Y distance for ANC300 Controller movement
                        XYdistance = PreviousPt - NextPt;
                        % Sketching Raster Scan Path
                        plot(vertcat(PreviousPt(:,1),NextPt(:,1)), vertcat(PreviousPt(:,2),NextPt(:,2)), 'LineStyle', '-', 'Color', [0.4, 0, 0.6,0.4], 'LineWidth',2.5)
                        PreviousPt = NextPt;
                        % Add to list for ease of use later
                        DistanceBetweenPoints(counter,:) = XYdistance;

                    end

                case 'topright'
                    LowerBound = StartingQD + [4*DiameterQD, - 2*DiameterQD];
                    UpperBound = StartingQD + [2*DiameterQD, - 4*DiameterQD];
                    PreviousPt = StartingQD;
                    while counter < repeatingNum
                        counter = counter + 1;
                        plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330]);
                        plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2]);

                        % Making a smaller boxed region to search for the next point
                        CoordCompUpper = FullQDList_sorted < UpperBound;
                        CoordCompLower = LowerBound < FullQDList_sorted;
                        % Identify corner points for an imaginary scquare around the next point
                        UpperPattern_mask = (CoordCompUpper(:, 1) == 0) & (CoordCompUpper(:, 2) == 0);
                        LowerPattern_mask = (CoordCompLower(:, 1) == 0) & (CoordCompLower(:, 2) == 0);
                        % Use logical indexing to keep the point that matches
                        NextPt = FullQDList_sorted(UpperPattern_mask & LowerPattern_mask, :);
                        LowerBound = NextPt + [4*DiameterQD, - 2*DiameterQD];
                        UpperBound = NextPt + [2*DiameterQD, - 4*DiameterQD];
                        % Finding X and Y distance for ANC300 Controller movement
                        XYdistance = PreviousPt - NextPt;
                        % Sketching Raster Scan Path
                        plot(vertcat(PreviousPt(:,1),NextPt(:,1)), vertcat(PreviousPt(:,2),NextPt(:,2)), 'LineStyle', '-', 'Color', [0.4, 0, 0.6,0.4], 'LineWidth',2.5)
                        PreviousPt = NextPt;
                        % Add to list for ease of use later
                        DistanceBetweenPoints(counter,:) = XYdistance;
                    end

                case 'topleft'
                    LowerBound = StartingQD - [4*DiameterQD, 2*DiameterQD];
                    UpperBound = StartingQD - [2*DiameterQD, 4*DiameterQD];
                    PreviousPt = StartingQD;
                    while counter < repeatingNum
                        counter = counter + 1;
                        plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330]);
                        plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2]);
                        % Making a smaller boxed region to search for the next point
                        CoordCompUpper = FullQDList_sorted < UpperBound;
                        CoordCompLower = LowerBound < FullQDList_sorted;
                        % Identify corner points for an imaginary scquare around the next point
                        UpperPattern_mask = (CoordCompUpper(:, 1) == 1) & (CoordCompUpper(:, 2) == 0);
                        LowerPattern_mask = (CoordCompLower(:, 1) == 1) & (CoordCompLower(:, 2) == 0);
                        % Use logical indexing to keep the point that matches
                        NextPt = FullQDList_sorted(UpperPattern_mask & LowerPattern_mask, :);
                        LowerBound = NextPt - [4*DiameterQD, 2*DiameterQD];
                        UpperBound = NextPt - [2*DiameterQD, 4*DiameterQD];
                        % Finding X and Y distance for ANC300 Controller movement
                        XYdistance = PreviousPt - NextPt;
                        % Sketching Raster Scan Path
                        plot(vertcat(PreviousPt(:,1),NextPt(:,1)), vertcat(PreviousPt(:,2),NextPt(:,2)), 'LineStyle', '-', 'Color', [0.4, 0, 0.6,0.4], 'LineWidth',2.5)
                        PreviousPt = NextPt;
                        % Add to list for ease of use later
                        DistanceBetweenPoints(counter,:) = XYdistance;
                    end
            end
        end

        function [DistanceBetweenPoints,NextPt,AllPointsOnDiagonal] = Axes_RasterScanPatt(obj,radiusQD,StartingQD,FullQDList_sorted,direction,repeatingNum)
            % Description:
                % - path finding for ANC300, user gives movement direction and the path finder finds the next QD in that direction  (similar to RasterScanPatt with additional features)
            % Inputs:
                % radiusQD - hardcoded approximate radius of each QD
                % startingQD - QD that the path finding starts from
                % FullQDlist_sorted - list of real and virtual QD 
                % direction - direction that the path finder looks for QD. Acceptable inputs are: 'bottomright','bottomleft','topright','topleft'
                % repeatingNum - number of QD found in that direction  
            % Outputs:
                % DistanceBetweenPoints - X and Y distance between each QD within specificed direction
                % Nextpt - centroid coordinate of Next QD within specified direction  
                % AllpointsOnDiagonal - returns every single next pt in order of which they were found in specific direction 
           
           
           
            % For direction can choose bottomright, bottomleft, upperright, upperleft
            DiameterQD = 2*radiusQD;
            DistanceBetweenPoints = zeros(repeatingNum,2);
            counter = 0;
            AllPointsOnDiagonal = [];

            switch lower(direction)
                case 'bottomright'
                    LowerBound = StartingQD + [2*DiameterQD,  4*DiameterQD];
                    UpperBound = StartingQD + [4*DiameterQD,  2*DiameterQD];
                    PreviousPt = StartingQD;
                    while counter < repeatingNum
                        counter = counter + 1;
                        %plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330]);
                        %plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2]);
                        % Making a smaller boxed region to search for the next point
                        CoordCompUpper = FullQDList_sorted < UpperBound;
                        CoordCompLower = LowerBound < FullQDList_sorted;
                        % Identify corner points for an imaginary scquare around the next point
                        UpperPattern_mask = (CoordCompUpper(:, 1) == 1) & (CoordCompUpper(:, 2) == 0);
                        LowerPattern_mask = (CoordCompLower(:, 1) == 1) & (CoordCompLower(:, 2) == 0);
                        % Use logical indexing to keep the point that matches
                        NextPt = FullQDList_sorted(UpperPattern_mask & LowerPattern_mask, :);
                        if isempty(NextPt)
                            break
                        end
                        LowerBound = NextPt + [2*DiameterQD,  4*DiameterQD];
                        UpperBound = NextPt + [4*DiameterQD,  2*DiameterQD];
                        % Finding X and Y distance for ANC300 Controller movement
                        XYdistance = PreviousPt - NextPt;
                        % Sketching Raster Scan Path
                        %plot(vertcat(PreviousPt(:,1),NextPt(:,1)), vertcat(PreviousPt(:,2),NextPt(:,2)), 'LineStyle', '-', 'Color', [0.4, 0, 0.6,0.4], 'LineWidth',2.5)
                        PreviousPt = NextPt;
                        % Add NextPt to a list of values
                        AllPointsOnDiagonal = vertcat(AllPointsOnDiagonal,NextPt);
                        % Add to list for ease of use later
                        DistanceBetweenPoints(counter,:) = XYdistance;
                    end

                case 'bottomleft'
                    LowerBound = StartingQD - [2*DiameterQD, - 4*DiameterQD];
                    UpperBound = StartingQD - [4*DiameterQD, - 2*DiameterQD];
                    PreviousPt = StartingQD;
                    while counter < repeatingNum
                        counter = counter + 1;
                        %plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330]);
                        %plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2]);
                        % Making a smaller boxed region to search for the next point
                        CoordCompUpper = FullQDList_sorted < UpperBound;
                        CoordCompLower = LowerBound < FullQDList_sorted;
                        % Identify corner points for an imaginary scquare around the next point
                        UpperPattern_mask = (CoordCompUpper(:, 1) == 0) & (CoordCompUpper(:, 2) == 0);
                        LowerPattern_mask = (CoordCompLower(:, 1) == 0) & (CoordCompLower(:, 2) == 0);
                        % Use logical indexing to keep the point that matches
                        NextPt = FullQDList_sorted(UpperPattern_mask & LowerPattern_mask, :);
                        if isempty(NextPt)
                            break
                        end
                        LowerBound = NextPt - [2*DiameterQD, - 4*DiameterQD];
                        UpperBound = NextPt - [4*DiameterQD, - 2*DiameterQD];
                        % Finding X and Y distance for ANC300 Controller movement
                        XYdistance = PreviousPt - NextPt;
                        % Sketching Raster Scan Path
                        %plot(vertcat(PreviousPt(:,1),NextPt(:,1)), vertcat(PreviousPt(:,2),NextPt(:,2)), 'LineStyle', '-', 'Color', [0.4, 0, 0.6,0.4], 'LineWidth',2.5)
                        PreviousPt = NextPt;
                        % Add NextPt to a list of values
                        AllPointsOnDiagonal = vertcat(AllPointsOnDiagonal,NextPt);
                        % Add to list for ease of use later
                        DistanceBetweenPoints(counter,:) = XYdistance;

                    end

                case 'topright'
                    LowerBound = StartingQD + [4*DiameterQD, - 2*DiameterQD];
                    UpperBound = StartingQD + [2*DiameterQD, - 4*DiameterQD];
                    PreviousPt = StartingQD;
                    while counter < repeatingNum
                        counter = counter + 1;
                        %plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330]);
                        %plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2]);

                        % Making a smaller boxed region to search for the next point
                        CoordCompUpper = FullQDList_sorted < UpperBound;
                        CoordCompLower = LowerBound < FullQDList_sorted;
                        % Identify corner points for an imaginary scquare around the next point
                        UpperPattern_mask = (CoordCompUpper(:, 1) == 0) & (CoordCompUpper(:, 2) == 0);
                        LowerPattern_mask = (CoordCompLower(:, 1) == 0) & (CoordCompLower(:, 2) == 0);
                        % Use logical indexing to keep the point that matches
                        NextPt = FullQDList_sorted(UpperPattern_mask & LowerPattern_mask, :);
                        if isempty(NextPt)
                            break
                        end
                        LowerBound = NextPt + [4*DiameterQD, - 2*DiameterQD];
                        UpperBound = NextPt + [2*DiameterQD, - 4*DiameterQD];
                        % Finding X and Y distance for ANC300 Controller movement
                        XYdistance = PreviousPt - NextPt;
                        % Sketching Raster Scan Path
                        %plot(vertcat(PreviousPt(:,1),NextPt(:,1)), vertcat(PreviousPt(:,2),NextPt(:,2)), 'LineStyle', '-', 'Color', [0.4, 0, 0.6,0.4], 'LineWidth',2.5)
                        PreviousPt = NextPt;
                        % Add NextPt to a list of values
                        AllPointsOnDiagonal = vertcat(AllPointsOnDiagonal,NextPt);
                        % Add to list for ease of use later
                        DistanceBetweenPoints(counter,:) = XYdistance;
                    end

                case 'topleft'
                    LowerBound = StartingQD - [4*DiameterQD, 2*DiameterQD];
                    UpperBound = StartingQD - [2*DiameterQD, 4*DiameterQD];
                    PreviousPt = StartingQD;
                    while counter < repeatingNum
                        counter = counter + 1;
                        %plot(LowerBound(1),LowerBound(2),"Marker","o","LineWidth",2,"MarkerSize",5,"MarkerEdgeColor",[0.2010 0.7450 0.9330]);
                        %plot(UpperBound(1),UpperBound(2),"Marker","o","LineWidth",2,"Markersize",5,"MarkerEdgeColor",[1, 0.75, 0.2]);
                        % Making a smaller boxed region to search for the next point
                        CoordCompUpper = FullQDList_sorted < UpperBound;
                        CoordCompLower = LowerBound < FullQDList_sorted;
                        % Identify corner points for an imaginary scquare around the next point
                        UpperPattern_mask = (CoordCompUpper(:, 1) == 1) & (CoordCompUpper(:, 2) == 0);
                        LowerPattern_mask = (CoordCompLower(:, 1) == 1) & (CoordCompLower(:, 2) == 0);
                        % Use logical indexing to keep the point that matches
                        NextPt = FullQDList_sorted(UpperPattern_mask & LowerPattern_mask, :);
                        if isempty(NextPt)
                            break
                        end
                        LowerBound = NextPt - [4*DiameterQD, 2*DiameterQD];
                        UpperBound = NextPt - [2*DiameterQD, 4*DiameterQD];
                        % Finding X and Y distance for ANC300 Controller movement
                        XYdistance = PreviousPt - NextPt;
                        % Sketching Raster Scan Path
                        %plot(vertcat(PreviousPt(:,1),NextPt(:,1)), vertcat(PreviousPt(:,2),NextPt(:,2)), 'LineStyle', '-', 'Color', [0.4, 0, 0.6,0.4], 'LineWidth',2.5)
                        PreviousPt = NextPt;
                        % Add NextPt to a list of values
                        AllPointsOnDiagonal = vertcat(AllPointsOnDiagonal,NextPt);
                        % Add to list for ease of use later
                        DistanceBetweenPoints(counter,:) = XYdistance;
                    end
            end
            AllPointsOnDiagonal = vertcat(StartingQD,AllPointsOnDiagonal);
        end

        function ANC300Movement(obj,Voltage_X,Frequency_X,Voltage_Y,Frequency_Y,Step_number_X,Step_number_Y,Axis_ID_Direction,ANC300)
            % Description:
                % - sets the voltage and frequency of each axis within piezo and sends movement commands to piezo
            % Inputs:
                % Axis_ID_Direction - stepping direction. Accpetable inputs: "1 up switch", "2 up switch", "1 down switch", "2 down switch"
                % Rest of inputs are self explanatory 
            % Outputs:
                % No output variable as function only writes and sends serial commands to the ANC300   
            
            switch lower(Axis_ID_Direction)
                case "1 up switch"
                    axis = "X";
                    % Setting each axes unused to grounded mode and active axis to stepping mode
                    fprintf(ANC300,"setm 2 gnd");
                    fprintf(ANC300,"setm 3 gnd");
                    fprintf(ANC300,"setm 1 stp");

                    % Setting respective Frequency and Voltage Values
                    Freq_axis_X = "setf 1" + " " + num2str(Frequency_X);
                    fprintf(ANC300,Freq_axis_X);

                    Volt_axis_X = "setv 1" + " " + num2str(Voltage_X);
                    fprintf(ANC300,Volt_axis_X);

                    % Sending Command to start Stepping
                    Step_amount_x = "stepu 1" + " " + num2str(Step_number_X);
                    fprintf("The stepping process is commencing for axis %s\n\n",axis)
                    startPt = tic;
                    fprintf(ANC300,Step_amount_x);
                    fprintf(ANC300,"stepw 1");
                    total_time = toc(startPt);
                    fprintf("Stepping is complete and it took %.5f seconds\n",total_time);

                case "1 down switch"
                    axis = "X";
                    % Setting each axes unused to grounded mode and active axis to stepping mode
                    fprintf(ANC300,"setm 2 gnd");
                    fprintf(ANC300,"setm 3 gnd");
                    fprintf(ANC300,"setm 1 stp");

                    % Setting respective Frequency and Voltage Values
                    Freq_axis_X = "setf 1" + " " + num2str(Frequency_X);
                    fprintf(ANC300,Freq_axis_X);

                    Volt_axis_X = "setv 1" + " " + num2str(Voltage_X);
                    fprintf(ANC300,Volt_axis_X);

                    % Sending Command to start Stepping
                    Step_amount_x = "stepd 1" + " " + num2str(Step_number_X);
                    fprintf("The stepping process is commencing for axis %s\n\n",axis)
                    startPt = tic;
                    fprintf(ANC300,Step_amount_x);
                    fprintf(ANC300,"stepw 1");
                    total_time = toc(startPt);
                    fprintf("Stepping is complete and it took %.5f seconds\n",total_time);

                case "2 up switch"
                    axis = "Y";
                    % Setting each axes unused to grounded mode and active axis to stepping mode
                    fprintf(ANC300,"setm 1 gnd");
                    fprintf(ANC300,"setm 3 gnd");
                    fprintf(ANC300,"setm 2 stp");

                    % Setting respective Frequency and Voltage Values
                    Freq_axis_Y = "setf 2" + " " + num2str(Frequency_Y);
                    fprintf(ANC300,Freq_axis_Y);

                    Volt_axis_Y = "setv 2" + " " + num2str(Voltage_Y);
                    fprintf(ANC300,Volt_axis_Y);

                    % Sending Command to start Stepping
                    Step_amount_Y = "stepu 2" + " " + num2str(Step_number_Y);
                    fprintf("The stepping process is commencing for axis %s\n\n",axis)
                    startPt = tic;
                    fprintf(ANC300,Step_amount_Y);
                    fprintf(ANC300,"stepw 2");
                    total_time = toc(startPt);
                    fprintf("Stepping is complete and it took %.5f seconds\n",total_time);

                case "2 down switch"
                    axis = "Y";
                    % Setting each axes unused to grounded mode and active axis to stepping mode
                    fprintf(ANC300,"setm 1 gnd");
                    fprintf(ANC300,"setm 3 gnd");
                    fprintf(ANC300,"setm 2 stp");

                    % Setting respective Frequency and Voltage Values
                    Freq_axis_Y = "setf 2" + " " + num2str(Frequency_Y);
                    fprintf(ANC300,Freq_axis_Y);

                    Volt_axis_Y = "setv 2" + " " + num2str(Voltage_Y);
                    fprintf(ANC300,Volt_axis_Y);

                    % Sending Command to start Stepping
                    Step_amount_Y = "stepd 2" + " " + num2str(Step_number_Y);
                    fprintf("The stepping process is commencing for axis %s\n\n",axis)
                    startPt = tic;
                    fprintf(ANC300,Step_amount_Y);
                    fprintf(ANC300,"stepw 2");
                    total_time = toc(startPt);
                    fprintf("Stepping is complete and it took %.5f seconds\n",total_time);
                otherwise
                    error('Invalid Axis_ID. Please provide "1" for X-axis or "2" for Y-axis.\n');
            end
        end

        function [n, m] = findSubplotDims(obj,numPlots)
            % Find the closest factors of numPlots that are as close to a square as possible
            
            % Initialize the best dimensions
            n = 1;
            m = numPlots;

            % Loop through possible values for n and m
            for i = 1:ceil(sqrt(numPlots))
                if mod(numPlots, i) == 0
                    % If i is a factor, find the corresponding m
                    j = numPlots / i;
                    % Update n and m to minimize the aspect ratio difference
                    if abs(i - j) < abs(n - m)
                        n = i;
                        m = j;
                    end
                end
            end

            % If n*m is less than numPlots, increase n or m
            if n * m < numPlots
                if n < m
                    n = n + 1;
                else
                    m = m + 1;
                end
            end
        end

    end
end

