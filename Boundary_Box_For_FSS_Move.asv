% Boundary Box Around QD 
% Parameters
% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
% Object with all required functions
my_obj = functionsContainer; 

% Adding needed pathways depending on Device - for lab purposes always use device name LAB 
my_obj.AddPathFunc("LAB")


% Filtering Settings
scaling = 0.5; 
skyBlue = [0.53, 0.81, 0.92]; 
radii_big_circle = 500; 
center_big_circle = [650,500]; 
sigma_flatfield = 35; 
Salt_pepper_pixel_factor = [20 20]; 
Min_circle_area = 200;
radiusQD = 25;

% LED 
LEDSpotCentroid = my_obj.LED_Cooordinate_Identifer("","Read","LAB"); 
LEDSpotCentroidX = LEDSpotCentroid(1);
LEDSpotCentroidY = LEDSpotCentroid(2);

% x y factors for small movement 
Read_XY_factor = XY_Factor_Identifier(obj,"","Read","LAB");
x_factor = Read_XY_factor.X_factor; %(Steps/pixels units)
y_factor = Read_XY_factor.Y_factor; %(Steps/pixels units)

% Defining Frequency
Frequency = 20; 

% Define the number of parallel lines and their separation
num_lines = 9; % Num lines on each side of the original line
sep_red = 345; % Separation distance red lines
sep_blue = 370; % Seperation distance blue lines

angle = 45; %43.696474776653320; % use the angle found by the algorithm in the XYANC300Axes script 
% --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    
[StartingQD,StartingQD_Rotated,Rotated_Table_FullQDList_sorted,Table_FullQDList_sorted] = app.MyFuncs.Precision_Locking_Matlab(ANC300,QD_counter,vid_UI,src_UI,20);
chosen_QD_Coords = StartingQD; 

% Coordinates of upper and lower boundary lines 
y_bottom = chosen_QD_Coords(2) + 2.5*radiusQD;
y_top = chosen_QD_Coords(2) - 2.5*radiusQD;

% Coordinates of left and right boundary lines 
x_left = chosen_QD_Coords(1) - 2.5*radiusQD; 
x_right = chosen_QD_Coords(1) + 2.5*radiusQD; vert_line = y_top:y_bottom;


num_points_horz = length(x_left:x_right);
num_points_vert = length(y_top:y_bottom);

y_top_pts = ones(1,num_points_horz) * y_top;
y_btm_pts = ones(1,num_points_horz) * y_bottom;

x_left_pts = ones(1,num_points_vert) * x_left; 
x_right_pts = ones(1,num_points_vert) * x_right; 

horz_line = x_left:x_right;
vert_line = y_top:y_bottom;

% Creating mesh grid for each spot to check and go to 
% Define step size (adjust as needed)
step_size = radiusQD/1.4; % Distance between points

% Generate grid points using meshgrid
[x_grid, y_grid] = meshgrid(x_left:step_size:x_right, y_top:step_size:y_bottom);
[grid_size,~] = size(x_grid); 

% Flatten the grid matrices into vectors for plotting
x_points = x_grid(:);
y_points = y_grid(:);

% Define empty Matrix with coordinates 
raster_order_points = zeros(length(x_points),2);

% Get Unique X and Y vals
Unique_x_vals = unique(x_points);
Unique_y_vals = unique(y_points);

ID = 1; 
for columns = 1:grid_size
    for rows = 1:grid_size
        if mod(columns,2) == 0
            raster_order_points(ID,1) = Unique_x_vals(end+1-rows);
        else
            raster_order_points(ID,1) = Unique_x_vals(rows);
        end
        ID = ID + 1; 
    end
    raster_order_points(columns*grid_size-(grid_size-1):columns*grid_size,2) = Unique_y_vals(columns);
end


% rotating raster scan points 
raster_order_points_X_rotated = center_pt(1) + (raster_order_points(:,1) - center_pt(1)) * cos(theta) - (raster_order_points(:,2) - center_pt(2)) * sin(theta);
raster_order_points_Y_rotated = center_pt(2) + (raster_order_points(:,1) - center_pt(1)) * sin(theta) + (raster_order_points(:,2) - center_pt(2)) * cos(theta);
raster_order_points_rotated = horzcat(raster_order_points_X_rotated,raster_order_points_Y_rotated); 

% Excitation laser rotated
LEDSpotCentroidX_rotated = center_pt(1) + (LEDSpotCentroid(1) - center_pt(1)) * cos(theta) - (LEDSpotCentroid(2) - center_pt(2)) * sin(theta);
LEDSpotCentroidY_rotated = center_pt(2) + (LEDSpotCentroid(1) - center_pt(1)) * sin(theta) + (LEDSpotCentroid(2) - center_pt(2)) * cos(theta);
LEDSpotCentroid_rotated = horzcat(LEDSpotCentroidX_rotated,LEDSpotCentroidY_rotated);



% Finding the differences in the steps in order to start moving to them 
First_Movement = LEDSpotCentroid_rotated - raster_order_points_rotated(1,:);
[direction] = my_obj.ClosestPtDirection(First_Movement); 

% Moving to the first point of start
my_obj.Dual_ANC300_Movement(First_Movement(1),First_Movement(2),direction,ANC300,Frequency,x_factor,y_factor)
pause(0.2)

% get initial photon count 
init_photon_count = py.ID900_Func.query_photon_counter(Photon_count_init); 


% initialize all the values for full scan  
relative_loc = [0 0];
data_table = table(relative_loc,init_photon_count,'VariableNames', {'Positions', 'PeakCounts'}); 
total_amount = length(x_points);
max_photon_count = 0; 
 

for num_scans = 1:2 
        
    % Calculating rest of the movements required 
    for interval = 2:size(raster_order_points_rotated,1)
    
        % Finding the differences in the steps in order to start moving to them 
        Pixel_difference = raster_order_points_rotated(interval,:) - raster_order_points_rotated(interval-1,:);
        [direction] = my_obj.ClosestPtDirection(Pixel_difference);
    
        % Moving to the next point 
        my_obj.Dual_ANC300_Movement(Pixel_difference(1),Pixel_difference(2),direction,ANC300,Frequency,x_factor,y_factor)
        pause(0.2)

        % Read photon count
        photon_count = py.ID900_Func.query_photon_counter(Photon_count_init);

        % Update table
        new_row = {relative_loc, photon_count};
        data_table = [data_table; new_row]; 
        percentage_complete = percentage_complete + 1;


        % Update Message
        fprintf("Completed %d/%d",percentage_complete,total_amount)
        if photon_count > 0.85*max_photon_count & max_photon_count ~= 0 
            break_all = true; 
            break
        end
    end
   

    if break_all == true
        fprintf("sucessfully found highest count\n")
        break
        
    end

    % find maximum photon count from first scan 
    max_photon_count = max(data_table.PeakCounts); 
    
    if num_scans < 2
        QD_counter = [1 1];
        Precision_Locking_Matlab(obj,ANC300,QD_counter,vid_UI,src_UI,20); % trying to land on the exact dot
        pause(0.2)
        % assigning original data to a new variable to return later
        % if needed
        original_data_table = data_table;
        relative_loc = 0; 
    end
end

if save_plot == "Yes"
    % Extract data from table
    X_Coords = original_data_table{:,'Positions'}(:,1);
    Y_Coords = original_data_table{:,'Positions'}(:,2);
    Photon_count_vals = original_data_table{:,'PeakCounts'};
    
    
    % Extract unique X and Y values (assuming evenly spaced grid)
    xVals = unique(X_Coords);
    yVals = unique(Y_Coords); 
    
    % Determine grid size
    numCols = length(xVals);
    numRows = length(yVals);
    
    % Create an empty grid for intensity values
    Z = nan(numRows, numCols);
    
    % Fill the grid with intensity values based on coordinates
    for i = 1:size(X_Coords,1)
        xIdx = find(xVals == X_Coords(i));
        yIdx = find(yVals == Y_Coords(i));
        Z(yIdx, xIdx) = Photon_count_vals(i);
    end
    
    % Flip the Y-axis so (0,0) is at the top-left
    Z = flipud(Z);
    
    % Plot the data using imagesc
    figure;
    imagesc(xVals, yVals, Z);
    colormap(jet); % Change colormap if needed
    colorbar;
    axis equal tight;
    ax = gca;
    ax.YTickLabel = flip(ax.YTickLabel); % Reverse Y-axis labels
    ax.XAxisLocation = 'top'; % Moves X-axis labels to the top  
    set(gca, 'YDir', 'Normal'); % Ensure top-left origin
    xlabel('X');
    ylabel('Y');
    
    title('Raster Scan Photon Count');
    file_name = sprintf("C:\\Users\\Quantum Dot\\Desktop\\Bera Yavuz - ANC300 Movement and Images\\FSS_Photon_Count_Scan\\Photon_Count_Scan__[%d %d]",QD); 
    saveas(gca,file_name)
end